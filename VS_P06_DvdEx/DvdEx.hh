// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __DvdEx_hh__
#define __DvdEx_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE DvdEx

_CORBA_MODULE_BEG

  enum Genre { g_undefined, SciFi, Comedy, Action, Horror, Docu /*, __max_Genre=0xffffffff */ };
  typedef Genre& Genre_out;

  enum StatusType { s_undefined, available, lent /*, __max_StatusType=0xffffffff */ };
  typedef StatusType& StatusType_out;

  struct DvdExMedia {
    typedef _CORBA_ConstrType_Variable_Var<DvdExMedia> _var_type;

    
    ::CORBA::Long ObjectId;

    ::CORBA::Long ProviderId;

    Genre Type;

    ::CORBA::String_member Title;

    ::CORBA::String_member ProductionCountry;

    ::CORBA::Short ProductionYear;

    ::CORBA::Short Length;

    StatusType Status;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DvdExMedia::_var_type DvdExMedia_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DvdExMedia,DvdExMedia_var > DvdExMedia_out;

  struct DvdExProvider {
    typedef _CORBA_ConstrType_Variable_Var<DvdExProvider> _var_type;

    
    ::CORBA::Long ObjectId;

    ::CORBA::String_member Name;

    ::CORBA::String_member FirstName;

    ::CORBA::Long ZIPCode;

    ::CORBA::String_member Address;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DvdExProvider::_var_type DvdExProvider_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DvdExProvider,DvdExProvider_var > DvdExProvider_out;

  class ServerException : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member reason;

  

    inline ServerException() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ServerException(const ServerException&);
    ServerException(const char* i_reason);
    ServerException& operator=(const ServerException&);
    virtual ~ServerException();
    virtual void _raise() const;
    static ServerException* _downcast(::CORBA::Exception*);
    static const ServerException* _downcast(const ::CORBA::Exception*);
    static inline ServerException* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class DvdExMediaSeq_var;

  class DvdExMediaSeq : public _CORBA_Unbounded_Sequence< DvdExMedia >  {
  public:
    typedef DvdExMediaSeq_var _var_type;
    inline DvdExMediaSeq() {}
    inline DvdExMediaSeq(const DvdExMediaSeq& _s)
      : _CORBA_Unbounded_Sequence< DvdExMedia > (_s) {}

    inline DvdExMediaSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< DvdExMedia > (_max) {}
    inline DvdExMediaSeq(_CORBA_ULong _max, _CORBA_ULong _len, DvdExMedia* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< DvdExMedia > (_max, _len, _val, _rel) {}

  

    inline DvdExMediaSeq& operator = (const DvdExMediaSeq& _s) {
      _CORBA_Unbounded_Sequence< DvdExMedia > ::operator=(_s);
      return *this;
    }
  };

  class DvdExMediaSeq_out;

  class DvdExMediaSeq_var {
  public:
    inline DvdExMediaSeq_var() : _pd_seq(0) {}
    inline DvdExMediaSeq_var(DvdExMediaSeq* _s) : _pd_seq(_s) {}
    inline DvdExMediaSeq_var(const DvdExMediaSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DvdExMediaSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DvdExMediaSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DvdExMediaSeq_var& operator = (DvdExMediaSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DvdExMediaSeq_var& operator = (const DvdExMediaSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DvdExMediaSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline DvdExMedia& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DvdExMediaSeq* operator -> () { return _pd_seq; }
    inline const DvdExMediaSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DvdExMediaSeq& () const { return *_pd_seq; }
#else
    inline operator const DvdExMediaSeq& () const { return *_pd_seq; }
    inline operator DvdExMediaSeq& () { return *_pd_seq; }
#endif
      
    inline const DvdExMediaSeq& in() const { return *_pd_seq; }
    inline DvdExMediaSeq&       inout()    { return *_pd_seq; }
    inline DvdExMediaSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DvdExMediaSeq* _retn() { DvdExMediaSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DvdExMediaSeq_out;
    
  private:
    DvdExMediaSeq* _pd_seq;
  };

  class DvdExMediaSeq_out {
  public:
    inline DvdExMediaSeq_out(DvdExMediaSeq*& _s) : _data(_s) { _data = 0; }
    inline DvdExMediaSeq_out(DvdExMediaSeq_var& _s)
      : _data(_s._pd_seq) { _s = (DvdExMediaSeq*) 0; }
    inline DvdExMediaSeq_out(const DvdExMediaSeq_out& _s) : _data(_s._data) {}
    inline DvdExMediaSeq_out& operator = (const DvdExMediaSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DvdExMediaSeq_out& operator = (DvdExMediaSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator DvdExMediaSeq*&()  { return _data; }
    inline DvdExMediaSeq*& ptr()       { return _data; }
    inline DvdExMediaSeq* operator->() { return _data; }

    inline DvdExMedia& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DvdExMediaSeq*& _data;

  private:
    DvdExMediaSeq_out();
    DvdExMediaSeq_out& operator=(const DvdExMediaSeq_var&);
  };

  class DvdExProviderSeq_var;

  class DvdExProviderSeq : public _CORBA_Unbounded_Sequence< DvdExProvider >  {
  public:
    typedef DvdExProviderSeq_var _var_type;
    inline DvdExProviderSeq() {}
    inline DvdExProviderSeq(const DvdExProviderSeq& _s)
      : _CORBA_Unbounded_Sequence< DvdExProvider > (_s) {}

    inline DvdExProviderSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< DvdExProvider > (_max) {}
    inline DvdExProviderSeq(_CORBA_ULong _max, _CORBA_ULong _len, DvdExProvider* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< DvdExProvider > (_max, _len, _val, _rel) {}

  

    inline DvdExProviderSeq& operator = (const DvdExProviderSeq& _s) {
      _CORBA_Unbounded_Sequence< DvdExProvider > ::operator=(_s);
      return *this;
    }
  };

  class DvdExProviderSeq_out;

  class DvdExProviderSeq_var {
  public:
    inline DvdExProviderSeq_var() : _pd_seq(0) {}
    inline DvdExProviderSeq_var(DvdExProviderSeq* _s) : _pd_seq(_s) {}
    inline DvdExProviderSeq_var(const DvdExProviderSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DvdExProviderSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DvdExProviderSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DvdExProviderSeq_var& operator = (DvdExProviderSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DvdExProviderSeq_var& operator = (const DvdExProviderSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DvdExProviderSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline DvdExProvider& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DvdExProviderSeq* operator -> () { return _pd_seq; }
    inline const DvdExProviderSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DvdExProviderSeq& () const { return *_pd_seq; }
#else
    inline operator const DvdExProviderSeq& () const { return *_pd_seq; }
    inline operator DvdExProviderSeq& () { return *_pd_seq; }
#endif
      
    inline const DvdExProviderSeq& in() const { return *_pd_seq; }
    inline DvdExProviderSeq&       inout()    { return *_pd_seq; }
    inline DvdExProviderSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DvdExProviderSeq* _retn() { DvdExProviderSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DvdExProviderSeq_out;
    
  private:
    DvdExProviderSeq* _pd_seq;
  };

  class DvdExProviderSeq_out {
  public:
    inline DvdExProviderSeq_out(DvdExProviderSeq*& _s) : _data(_s) { _data = 0; }
    inline DvdExProviderSeq_out(DvdExProviderSeq_var& _s)
      : _data(_s._pd_seq) { _s = (DvdExProviderSeq*) 0; }
    inline DvdExProviderSeq_out(const DvdExProviderSeq_out& _s) : _data(_s._data) {}
    inline DvdExProviderSeq_out& operator = (const DvdExProviderSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DvdExProviderSeq_out& operator = (DvdExProviderSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator DvdExProviderSeq*&()  { return _data; }
    inline DvdExProviderSeq*& ptr()       { return _data; }
    inline DvdExProviderSeq* operator->() { return _data; }

    inline DvdExProvider& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DvdExProviderSeq*& _data;

  private:
    DvdExProviderSeq_out();
    DvdExProviderSeq_out& operator=(const DvdExProviderSeq_var&);
  };

#ifndef __DvdEx_mDvdExRepository__
#define __DvdEx_mDvdExRepository__

  class DvdExRepository;
  class _objref_DvdExRepository;
  class _impl_DvdExRepository;
  
  typedef _objref_DvdExRepository* DvdExRepository_ptr;
  typedef DvdExRepository_ptr DvdExRepositoryRef;

  class DvdExRepository_Helper {
  public:
    typedef DvdExRepository_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DvdExRepository, DvdExRepository_Helper> DvdExRepository_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DvdExRepository,DvdExRepository_Helper > DvdExRepository_out;

#endif

  // interface DvdExRepository
  class DvdExRepository {
  public:
    // Declarations for this interface type.
    typedef DvdExRepository_ptr _ptr_type;
    typedef DvdExRepository_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DvdExRepository :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void save();
    void addProvider(const ::DvdEx::DvdExProvider& p);
    void delProvider(::CORBA::Long id);
    DvdExProvider* getProvider(::CORBA::Long id);
    DvdExProviderSeq* getProviders();
    void addMedia(const ::DvdEx::DvdExMedia& p);
    void delMedia(::CORBA::Long id);
    DvdExMedia* getMedia(::CORBA::Long id);
    DvdExMediaSeq* getMediaOfType(::DvdEx::Genre type);
    DvdExMediaSeq* getMediaYoungerThan(::CORBA::Short year);
    DvdExMediaSeq* getMediaAvailable();
    ::CORBA::Long currentMaxProviderId();
    ::CORBA::Long currentMaxMediaId();

    inline _objref_DvdExRepository()  { _PR_setobj(0); }  // nil
    _objref_DvdExRepository(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DvdExRepository();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DvdExRepository(const _objref_DvdExRepository&);
    _objref_DvdExRepository& operator = (const _objref_DvdExRepository&);
    // not implemented

    friend class DvdExRepository;
  };

  class _pof_DvdExRepository : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DvdExRepository() : _OMNI_NS(proxyObjectFactory)(DvdExRepository::_PD_repoId) {}
    virtual ~_pof_DvdExRepository();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DvdExRepository :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DvdExRepository();

    virtual void save() = 0;
    virtual void addProvider(const ::DvdEx::DvdExProvider& p) = 0;
    virtual void delProvider(::CORBA::Long id) = 0;
    virtual DvdExProvider* getProvider(::CORBA::Long id) = 0;
    virtual DvdExProviderSeq* getProviders() = 0;
    virtual void addMedia(const ::DvdEx::DvdExMedia& p) = 0;
    virtual void delMedia(::CORBA::Long id) = 0;
    virtual DvdExMedia* getMedia(::CORBA::Long id) = 0;
    virtual DvdExMediaSeq* getMediaOfType(::DvdEx::Genre type) = 0;
    virtual DvdExMediaSeq* getMediaYoungerThan(::CORBA::Short year) = 0;
    virtual DvdExMediaSeq* getMediaAvailable() = 0;
    virtual ::CORBA::Long currentMaxProviderId() = 0;
    virtual ::CORBA::Long currentMaxMediaId() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_DvdEx
_CORBA_MODULE_BEG

  class DvdExRepository :
    public virtual DvdEx::_impl_DvdExRepository,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DvdExRepository();

    inline ::DvdEx::DvdExRepository_ptr _this() {
      return (::DvdEx::DvdExRepository_ptr) _do_this(::DvdEx::DvdExRepository::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_DvdEx
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(DvdEx::Genre _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (DvdEx::Genre& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= DvdEx::Docu) {
    _e = (DvdEx::Genre) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(DvdEx::StatusType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (DvdEx::StatusType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= DvdEx::lent) {
    _e = (DvdEx::StatusType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
DvdEx::DvdExRepository::_marshalObjRef(::DvdEx::DvdExRepository_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_DvdEx
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_DvdEx
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_DvdEx
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_DvdEx
#endif

#endif  // __DvdEx_hh__

